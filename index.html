<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dodge & Collect</title>
  <style>
    :root{
      --bg:#070b14; --fg:#e8eefc; --muted:#9bb0d9; --line:rgba(255,255,255,.12);
      --card:rgba(18,26,43,.9);
      --shadow:0 16px 50px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background: radial-gradient(1000px 600px at 20% 0%, rgba(122,162,255,.18), transparent 60%),
                  radial-gradient(1000px 600px at 80% 20%, rgba(96,211,148,.10), transparent 60%),
                  var(--bg);
      color:var(--fg);
      display:flex; min-height:100vh; align-items:center; justify-content:center;
      padding:18px;
    }
    .wrap{max-width:980px; width:100%; display:grid; grid-template-columns: 1fr 320px; gap:14px;}
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .hd{padding:12px 14px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; gap:12px; align-items:center;}
    .title{font-weight:700; letter-spacing:.2px}
    .sub{color:var(--muted); font-size:12px}
    .bd{padding:12px 14px}
    canvas{width:100%; height:auto; display:block; background:rgba(0,0,0,.25); border-radius:14px; border:1px solid rgba(255,255,255,.10)}
    .stats{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;}
    .stat{
      padding:10px 12px; border-radius:14px; border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .k{color:var(--muted); font-size:12px}
    .v{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; font-size:18px; margin-top:4px}
    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    button{
      cursor:pointer;
      border-radius:12px; border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--fg);
      padding:10px 12px;
      font:inherit;
    }
    button:hover{background: rgba(255,255,255,.10)}
    .primary{border-color: rgba(122,162,255,.45); background: rgba(122,162,255,.14)}
    .primary:hover{background: rgba(122,162,255,.20)}

    .help{color:var(--muted); font-size:12px; line-height:1.35}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-size:12px; color:var(--muted)
    }
    .row{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
    .sep{height:1px; background:rgba(255,255,255,.10); margin:12px 0}

    /* Joystick under buttons */
    .joyWrap{
      display:none;
      margin-top:12px;
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .joyArea{
      position:relative;
      width:150px; height:150px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      touch-action:none;
      margin:0 auto;
    }
    .joyKnob{
      position:absolute;
      left:50%; top:50%;
      width:52px; height:52px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(122,162,255,.18);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    @media (max-width: 920px){
      .wrap{grid-template-columns:1fr}
      .joyWrap{display:block}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card">
      <div class="hd">
        <div>
          <div class="title">Dodge & Collect</div>
          <div class="sub">Collect imaging tokens. Avoid black jelly beans. Survive as long as you can.</div>
        </div>
        <span class="pill" id="statusPill">Press <b>Start</b></span>
      </div>
      <div class="bd">
        <canvas id="game" width="800" height="520"></canvas>

        <div class="stats">
          <div class="stat"><div class="k">Score</div><div class="v" id="score">0</div></div>
          <div class="stat"><div class="k">Best</div><div class="v" id="best">0</div></div>
          <div class="stat"><div class="k">Lives</div><div class="v" id="lives">3</div></div>
          <div class="stat"><div class="k">Level</div><div class="v" id="level">1</div></div>
        </div>

        <div class="btns">
          <button class="primary" id="btnStart">Start / Restart</button>
          <button id="btnPause">Pause</button>
        </div>

        <div class="joyWrap">
          <div class="help" style="margin:0 0 10px;">Touch joystick</div>
          <div class="joyArea" id="joyArea">
            <div class="joyKnob" id="joyKnob"></div>
          </div>
          <div class="help" style="margin-top:10px;">Tip: use your thumb here while watching the play area above.</div>
        </div>
      </div>
    </section>

    <aside class="card">
      <div class="hd">
        <div>
          <div class="title">Controls</div>
          <div class="sub">Keyboard or touch</div>
        </div>
      </div>
      <div class="bd">
        <div class="help">
          <div class="row">
            <span class="pill">Move: <b>WASD</b> or <b>Arrow keys</b></span>
            <span class="pill">Pause: <b>P</b></span>
          </div>
          <div class="sep"></div>
          <div>
            You are the blue circle.<br/>
            <b>X-ray token</b> = +10<br/>
            <b>Ultrasound triangle</b> = +20<br/>
            <b>CT square</b> = +30<br/>
            <b>MRI pentagon</b> = +40<br/>
            <b>Black jelly beans</b>, your boss taught you wrong = lose a life<br/>
            Levels are based on <b>score</b> (not time).
          </div>
        </div>
      </div>
    </aside>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const livesEl = document.getElementById("lives");
  const levelEl = document.getElementById("level");
  const statusPill = document.getElementById("statusPill");

  const btnStart = document.getElementById("btnStart");
  const btnPause = document.getElementById("btnPause");

  // High score
  const BEST_KEY = "dodge_collect_best";
  let best = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = String(best);

  // Audio (ding)
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function ding() {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = "sine";
    o.frequency.setValueAtTime(880, t0);
    o.frequency.exponentialRampToValueAtTime(1320, t0 + 0.08);

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.25, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);

    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + 0.24);
  }

  // Game state
  let running = false;
  let paused  = false;
  let lastTs  = 0;

  const world = {
    w: canvas.width,
    h: canvas.height,
    level: 1,
    lives: 3,
    score: 0,
    speedMult: 1,
  };

  const player = {
    x: world.w * 0.5,
    y: world.h * 0.7,
    r: 14,
    vx: 0,
    vy: 0,
    maxSpeed: 320 * 1.3,
    accel: 1400 * 1.3,
    friction: 0.86
  };

  // Score-based leveling
  const POINTS_PER_LEVEL = 150;
  const MAX_LEVEL = 11;
  function levelFromScore(score){
    const lvl = 1 + Math.floor(score / POINTS_PER_LEVEL);
    return Math.max(1, Math.min(MAX_LEVEL, lvl));
  }

  // Level-up banner
  const levelTitles = {
    2: "intern",
    3: "resident",
    4: "junior registrar",
    5: "senior registrar",
    6: "Fellow",
    7: "Junior Consultant on Fellow Pay",
    8: "Junior Consultant",
    9: "Middle Career Boss",
    10: "Big Boss",
    11: "BOSS BOSS"
  };

  const levelBanner = { active:false, t:0, dur:2.0, level:1, title:"" };
  const startBanner = { active:true, t:0, dur:2.2 };

  function showLevelBanner(level) {
    levelBanner.active = true;
    levelBanner.t = 0;
    levelBanner.level = level;
    levelBanner.title = levelTitles[level] || "";
  }
  function showStartBanner() { startBanner.active = true; startBanner.t = 0; }

  function rand(min, max) { return min + Math.random() * (max - min); }

  // ========= Image packs from Wikimedia Commons (5 each) =========
  const PACKS = {
    xray: { category: "Category:X-rays_of_the_chest", urls: [], images: [], ready: false },
    us:   { category: "Category:Medical_ultrasound", urls: [], images: [], ready: false },
    ct:   { category: "Category:Computed_tomography_images", urls: [], images: [], ready: false },
    mri:  { category: "Category:Magnetic_resonance_imaging_of_the_normal_brain", urls: [], images: [], ready: false }
  };

  function commonsApi(params) {
    const base = "https://commons.wikimedia.org/w/api.php";
    const q = new URLSearchParams({ ...params, format: "json", origin: "*" });
    return `${base}?${q.toString()}`;
  }

  async function fetchCategoryFileTitles(category, limit = 25) {
    const url = commonsApi({
      action: "query",
      list: "categorymembers",
      cmtitle: category,
      cmtype: "file",
      cmlimit: String(limit)
    });
    const r = await fetch(url);
    const j = await r.json();
    const members = (j?.query?.categorymembers || []);
    return members.map(m => m.title).filter(t => /^File:/i.test(t));
  }

  // Chunked to avoid overlong URLs
  async function fetchFileImageUrls(fileTitles) {
    if (!fileTitles.length) return [];
    const CHUNK = 20;
    const allUrls = [];

    for (let i = 0; i < fileTitles.length; i += CHUNK) {
      const slice = fileTitles.slice(i, i + CHUNK);

      const url = commonsApi({
        action: "query",
        prop: "imageinfo",
        iiprop: "url",
        titles: slice.join("|")
      });

      const r = await fetch(url);
      const j = await r.json();
      const pages = j?.query?.pages || {};

      for (const k of Object.keys(pages)) {
        const info = pages[k]?.imageinfo?.[0];
        if (info?.url) allUrls.push(info.url);
      }
    }

    return allUrls;
  }

  function preloadImages(urls, want = 5) {
    return new Promise((resolve) => {
      const images = [];
      let idx = 0;

      function loadNext() {
        if (images.length >= want || idx >= urls.length) return resolve(images);
        const u = urls[idx++];

        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => { images.push(img); loadNext(); };
        img.onerror = () => { loadNext(); };
        img.src = u;
      }

      const parallel = 4;
      for (let i = 0; i < parallel; i++) loadNext();
    });
  }

  async function ensurePackReady(packKey, want = 5) {
    const pack = PACKS[packKey];
    if (!pack || pack.ready) return;

    try {
      const titles = await fetchCategoryFileTitles(pack.category, 25);
      const urls = await fetchFileImageUrls(titles);

      pack.urls = urls;
      pack.images = await preloadImages(urls, want);
      pack.ready = pack.images.length >= 1;
    } catch (e) {
      console.error("Pack load failed:", packKey, e);
      pack.ready = false;
    }
  }

  const hazards = [];
  const pickups = [];
  const popups  = [];

  // Equal probability for each token type (25% each)
  const TOKEN_TYPES = ["xray_token", "us_triangle", "ct_square", "mri_pentagon"];
  function pickTypeEqual() { return TOKEN_TYPES[(Math.random() * TOKEN_TYPES.length) | 0]; }

  function pickFromPack(packKey) {
    const p = PACKS[packKey];
    if (!p?.images?.length) return null;
    return p.images[(Math.random() * p.images.length) | 0];
  }

  function resetGame() {
    world.level = 1;
    world.lives = 3;
    world.score = 0;
    world.speedMult = 1;

    player.x = world.w * 0.5;
    player.y = world.h * 0.7;
    player.vx = 0;
    player.vy = 0;

    hazards.length = 0;
    pickups.length = 0;
    popups.length  = 0;

    for (let i = 0; i < 4; i++) spawnHazard();
    for (let i = 0; i < 6; i++) spawnPickup();

    showStartBanner();
    syncUI();
    statusPill.innerHTML = "Go!";
  }

  function syncUI() {
    scoreEl.textContent = String(world.score);
    bestEl.textContent  = String(best);
    livesEl.textContent = String(world.lives);
    levelEl.textContent = String(world.level);
  }

  function spawnHazard() {
    const size = rand(22, 48);
    const x = rand(0, world.w - size);
    const y = -size - rand(0, 200);
    const base = 140 + world.level * 14;
    hazards.push({
      x, y, w: size, h: size,
      vx: rand(-65, 65),
      vy: rand(base, base + 150) * world.speedMult
    });
  }

  function spawnPickup() {
    const type = pickTypeEqual();

    // DOUBLE token sizes
    const spec = (() => {
      switch (type) {
        case "xray_token":   return { score: 10, size: rand(24, 36), imgKey: "xray" };
        case "us_triangle":  return { score: 20, size: rand(28, 40), imgKey: "us"  };
        case "ct_square":    return { score: 30, size: rand(28, 40), imgKey: "ct"  };
        case "mri_pentagon": return { score: 40, size: rand(30, 44), imgKey: "mri" };
        default:             return { score: 10, size: rand(24, 36), imgKey: "xray" };
      }
    })();

    const r = spec.size;
    const x = rand(r, world.w - r);
    const y = -r - rand(0, 280);
    const base = 115 + world.level * 10;

    pickups.push({
      type,
      score: spec.score,
      x, y,
      size: spec.size,
      vx: rand(-35, 35),
      vy: rand(base, base + 125) * world.speedMult,
      imgKey: spec.imgKey,
      img: pickFromPack(spec.imgKey)
    });
  }

  // Controls
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d","p"," "].includes(k)) e.preventDefault();
    if (k === "p") togglePause();
    keys.add(k);
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // Touch joystick
  const joyArea = document.getElementById("joyArea");
  const joyKnob = document.getElementById("joyKnob");
  let joyActive = false;
  let joyVec = {x:0,y:0};

  function setKnob(nx, ny){
    const maxMove = 40;
    joyKnob.style.left = `calc(50% + ${nx * maxMove}px)`;
    joyKnob.style.top  = `calc(50% + ${ny * maxMove}px)`;
  }
  function resetKnob(){ joyKnob.style.left="50%"; joyKnob.style.top="50%"; }

  // Make Safari happier about touch
  if (joyArea) {
    joyArea.addEventListener("touchmove", (e) => e.preventDefault(), { passive: false });

    const onDown = (e) => { joyActive = true; joyArea.setPointerCapture(e.pointerId); onMove(e); };
    const onMove = (e) => {
      if (!joyActive) return;
      const rect = joyArea.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const dx = (e.clientX - cx);
      const dy = (e.clientY - cy);
      const max = rect.width * 0.33;
      const nx = Math.max(-1, Math.min(1, dx / max));
      const ny = Math.max(-1, Math.min(1, dy / max));
      joyVec = {x:nx, y:ny};
      setKnob(nx, ny);
    };
    const onUp = () => { joyActive = false; joyVec = {x:0,y:0}; resetKnob(); };

    joyArea.addEventListener("pointerdown", onDown);
    joyArea.addEventListener("pointermove", onMove);
    joyArea.addEventListener("pointerup", onUp);
    joyArea.addEventListener("pointercancel", onUp);
    joyArea.addEventListener("pointerleave", onUp);
  }

  function togglePause(){
    if (!running) return;
    paused = !paused;
    statusPill.innerHTML = paused ? "Paused" : "Go!";
    btnPause.textContent = paused ? "Resume" : "Pause";
  }

  // Start: wait for images before game begins
  btnStart.addEventListener("click", async () => {
    running = true;
    paused = false;
    btnPause.textContent = "Pause";

    ensureAudio();
    if (audioCtx && audioCtx.state === "suspended") {
      try { await audioCtx.resume(); } catch {}
    }

    statusPill.innerHTML = "Loading images…";

    await Promise.all([
      ensurePackReady("xray", 5),
      ensurePackReady("us", 5),
      ensurePackReady("ct", 5),
      ensurePackReady("mri", 5),
    ]);

    statusPill.innerHTML =
      `Images loaded: XR ${PACKS.xray.images.length} • US ${PACKS.us.images.length} • CT ${PACKS.ct.images.length} • MRI ${PACKS.mri.images.length}`;

    resetGame();
    lastTs = performance.now();
    requestAnimationFrame(loop);
  });

  btnPause.addEventListener("click", () => togglePause());

  function endGame() {
    running = false;
    paused = false;
    statusPill.innerHTML = `Game Over — press <b>Start</b>`;
    btnPause.textContent = "Pause";
    if (world.score > best) {
      best = world.score;
      localStorage.setItem(BEST_KEY, String(best));
    }
    syncUI();
  }

  function circleRectCollide(cx, cy, r, rx, ry, rw, rh){
    const px = Math.max(rx, Math.min(cx, rx + rw));
    const py = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - px;
    const dy = cy - py;
    return (dx*dx + dy*dy) <= r*r;
  }

  function circleCircleCollide(ax, ay, ar, bx, by, br){
    const dx = ax - bx, dy = ay - by;
    const rr = ar + br;
    return dx*dx + dy*dy <= rr*rr;
  }

  // Drawing helpers for image-clipped shapes
  function pathCircle(x, y, r) { ctx.arc(x, y, r, 0, Math.PI * 2); }
  function pathTriangle(x, y, r) {
    ctx.moveTo(x, y - r);
    ctx.lineTo(x - r * 0.9, y + r * 0.85);
    ctx.lineTo(x + r * 0.9, y + r * 0.85);
    ctx.closePath();
  }
  function pathSquare(x, y, r) {
    const s = r * 1.6;
    ctx.rect(x - s/2, y - s/2, s, s);
  }
  function pathPentagon(x, y, r) {
    for (let i = 0; i < 5; i++) {
      const a = (-Math.PI / 2) + i * (Math.PI * 2 / 5);
      const px = x + Math.cos(a) * r;
      const py = y + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath();
  }

  function drawImageClippedToPath(img, pathFn, x, y, size) {
    if (!img || !img.complete || img.naturalWidth === 0) return false;

    ctx.save();
    ctx.beginPath();
    pathFn(x, y, size);
    ctx.clip();

    const iw = img.naturalWidth, ih = img.naturalHeight;

    // Bigger zoom inside the shape
    const target = size * 3.2;

    const scale = Math.max(target / iw, target / ih);
    const dw = iw * scale, dh = ih * scale;

    ctx.globalAlpha = 0.95;
    ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);

    ctx.restore();
    return true;
  }

  // Jelly bean hazard draw
  function drawJellyBean(x, y, w, h) {
    ctx.save();

    const cx = x + w / 2;
    const cy = y + h / 2;
    const rx = w / 2;
    const ry = h / 2;

    ctx.translate(cx, cy);
    ctx.rotate(0.35);

    ctx.beginPath();
    ctx.moveTo(-rx * 0.6, -ry);
    ctx.bezierCurveTo(
      rx * 0.9, -ry,
      rx * 1.1, ry * 0.6,
      rx * 0.3, ry
    );
    ctx.bezierCurveTo(
      -rx * 1.1, ry * 1.1,
      -rx * 1.1, -ry * 0.2,
      -rx * 0.6, -ry
    );
    ctx.closePath();

    ctx.fillStyle = "rgba(15,15,15,0.95)";
    ctx.fill();

    // glossy highlight
    ctx.beginPath();
    ctx.ellipse(-rx * 0.2, -ry * 0.3, rx * 0.25, ry * 0.35, -0.3, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    ctx.fill();

    ctx.restore();
  }

  // Joystick shaping for DIRECT velocity mode
  function shapeStick(v){
    const dead = 0.10;
    const s = Math.max(0, Math.abs(v) - dead) / (1 - dead);
    const curved = Math.pow(s, 0.55);
    return Math.sign(v) * curved;
  }

  function update(dt){
    // keyboard
    let ax = 0, ay = 0;
    if (keys.has("arrowleft") || keys.has("a")) ax -= 1;
    if (keys.has("arrowright") || keys.has("d")) ax += 1;
    if (keys.has("arrowup") || keys.has("w")) ay -= 1;
    if (keys.has("arrowdown") || keys.has("s")) ay += 1;

    // joystick (direct)
    const jx = shapeStick(joyVec.x);
    const jy = shapeStick(joyVec.y);
    const stickMag = Math.hypot(jx, jy);

    if (stickMag > 0.001) {
      const targetVx = jx * player.maxSpeed;
      const targetVy = jy * player.maxSpeed;

      const snap = 22;
      const k = 1 - Math.exp(-snap * dt);

      player.vx += (targetVx - player.vx) * k;
      player.vy += (targetVy - player.vy) * k;
    } else {
      const len = Math.hypot(ax, ay);
      if (len > 1e-6) { ax /= len; ay /= len; }

      player.vx += ax * player.accel * dt;
      player.vy += ay * player.accel * dt;

      player.vx *= Math.pow(player.friction, dt * 60);
      player.vy *= Math.pow(player.friction, dt * 60);

      const sp = Math.hypot(player.vx, player.vy);
      if (sp > player.maxSpeed) {
        const s = player.maxSpeed / sp;
        player.vx *= s; player.vy *= s;
      }
    }

    player.x += player.vx * dt;
    player.y += player.vy * dt;

    player.x = Math.max(player.r, Math.min(world.w - player.r, player.x));
    player.y = Math.max(player.r, Math.min(world.h - player.r, player.y));

    // hazards
    for (const h of hazards) {
      h.x += h.vx * dt;
      h.y += h.vy * dt;
      if (h.x < 0) { h.x = 0; h.vx *= -1; }
      if (h.x + h.w > world.w) { h.x = world.w - h.w; h.vx *= -1; }
    }

    // pickups
    for (const p of pickups) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      const r = p.size;
      if (p.x < r) { p.x = r; p.vx *= -1; }
      if (p.x > world.w - r) { p.x = world.w - r; p.vx *= -1; }
    }

    // Maintain counts (fewer hazards)
    const desiredHaz = 3 + Math.min(8, Math.floor(world.level * 0.55));
    const desiredPickups = 7 + Math.min(10, Math.floor(world.level * 0.65));

    for (let i = hazards.length - 1; i >= 0; i--) {
      if (hazards[i].y > world.h + 140) hazards.splice(i, 1);
    }
    while (hazards.length < desiredHaz) spawnHazard();

    for (let i = pickups.length - 1; i >= 0; i--) {
      if (pickups[i].y > world.h + 140) pickups.splice(i, 1);
    }
    while (pickups.length < desiredPickups) spawnPickup();

    // Collisions: hazards (slightly forgiving bounds)
    for (let i = hazards.length - 1; i >= 0; i--) {
      const h = hazards[i];
      const hit = circleRectCollide(
        player.x, player.y, player.r * 0.9,
        h.x + h.w * 0.1, h.y + h.h * 0.1,
        h.w * 0.8, h.h * 0.8
      );
      if (hit) {
        hazards.splice(i, 1);
        world.lives -= 1;
        player.vx *= -0.35;
        player.vy *= -0.35;
        if (world.lives <= 0) {
          syncUI();
          endGame();
          return;
        }
        syncUI();
      }
    }

    // Collisions: pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
      const pck = pickups[i];
      if (circleCircleCollide(player.x, player.y, player.r, pck.x, pck.y, pck.size)) {
        pickups.splice(i, 1);
        world.score += pck.score;

        popups.push({
          x: pck.x, y: pck.y,
          vy: -55, life: 0.9, t: 0,
          text: `+${pck.score}`,
          color: "rgba(255,255,255,.92)"
        });

        syncUI();
      }
    }

    // Level check
    const newLevel = levelFromScore(world.score);
    if (newLevel !== world.level) {
      world.level = newLevel;
      world.speedMult = 1 + (world.level - 1) * 0.08;

      showLevelBanner(world.level);
      ding();

      spawnHazard();
      spawnPickup();
      if (world.level % 2 === 0) spawnPickup();

      syncUI();
    }

    // popups
    for (let i = popups.length - 1; i >= 0; i--) {
      const p = popups[i];
      p.t += dt;
      p.y += p.vy * dt;
      if (p.t >= p.life) popups.splice(i, 1);
    }

    // banners
    if (levelBanner.active) {
      levelBanner.t += dt;
      if (levelBanner.t >= levelBanner.dur) levelBanner.active = false;
    }
    if (startBanner.active) {
      startBanner.t += dt;
      if (startBanner.t >= startBanner.dur) startBanner.active = false;
    }
  }

  function draw(){
    ctx.clearRect(0, 0, world.w, world.h);

    // grid
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    for (let x = 40; x < world.w; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, world.h); ctx.stroke();
    }
    for (let y = 40; y < world.h; y += 40) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(world.w, y); ctx.stroke();
    }
    ctx.restore();

    // pickups
    for (const p of pickups) {
      if (!p.img) p.img = pickFromPack(p.imgKey);

      if (p.type === "xray_token") {
        const ok = drawImageClippedToPath(p.img, pathCircle, p.x, p.y, p.size);
        if (!ok) { ctx.beginPath(); pathCircle(p.x, p.y, p.size); ctx.fillStyle = "rgba(96,211,148,.85)"; ctx.fill(); }
        ctx.beginPath(); pathCircle(p.x, p.y, p.size);
        ctx.strokeStyle = "rgba(96,211,148,.75)"; ctx.lineWidth = 2; ctx.stroke();
      } else if (p.type === "us_triangle") {
        const ok = drawImageClippedToPath(p.img, pathTriangle, p.x, p.y, p.size);
        if (!ok) { ctx.fillStyle = "rgba(255,209,102,.92)"; ctx.beginPath(); pathTriangle(p.x, p.y, p.size); ctx.fill(); }
        ctx.strokeStyle = "rgba(255,255,255,.18)"; ctx.lineWidth = 2;
        ctx.beginPath(); pathTriangle(p.x, p.y, p.size); ctx.stroke();
      } else if (p.type === "ct_square") {
        const ok = drawImageClippedToPath(p.img, pathSquare, p.x, p.y, p.size);
        if (!ok) { ctx.fillStyle = "rgba(96,211,148,.95)"; ctx.beginPath(); pathSquare(p.x, p.y, p.size); ctx.fill(); }
        ctx.strokeStyle = "rgba(255,255,255,.14)"; ctx.lineWidth = 2;
        ctx.beginPath(); pathSquare(p.x, p.y, p.size); ctx.stroke();
      } else if (p.type === "mri_pentagon") {
        const ok = drawImageClippedToPath(p.img, pathPentagon, p.x, p.y, p.size);
        if (!ok) { ctx.fillStyle = "rgba(255,159,64,.92)"; ctx.beginPath(); pathPentagon(p.x, p.y, p.size); ctx.fill(); }
        ctx.strokeStyle = "rgba(255,255,255,.18)"; ctx.lineWidth = 2;
        ctx.beginPath(); pathPentagon(p.x, p.y, p.size); ctx.stroke();
      }
    }

    // hazards = black jelly beans
    for (const h of hazards) {
      drawJellyBean(h.x, h.y, h.w, h.h);
    }

    // player
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(122,162,255,.92)";
    ctx.fill();
    ctx.beginPath();
    ctx.arc(player.x - player.r*0.3, player.y - player.r*0.3, player.r*0.35, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.20)";
    ctx.fill();

    // popups
    ctx.save();
    ctx.font = "18px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    for (const p of popups) {
      const a = Math.max(0, 1 - (p.t / p.life));
      ctx.globalAlpha = 0.95 * a;
      ctx.fillStyle = p.color;
      ctx.strokeStyle = "rgba(0,0,0,.45)";
      ctx.lineWidth = 4;
      ctx.strokeText(p.text, p.x, p.y);
      ctx.fillText(p.text, p.x, p.y);
    }
    ctx.restore();

    // HUD + progress
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    ctx.fillRect(10, 10, 560, 32);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    const nextLevelAt = (world.level) * POINTS_PER_LEVEL;
    const toNext = (world.level >= MAX_LEVEL) ? 0 : Math.max(0, nextLevelAt - world.score);

    ctx.fillText(`Score ${world.score}  Lives ${world.lives}  Lvl ${world.level}  Next in ${toNext}`, 18, 31);
    ctx.restore();

    // Welcome banner (start)
    if (startBanner.active) {
      const p = startBanner.t / startBanner.dur;
      const flash = Math.max(0, 1 - p);
      const alpha = 0.12 + 0.6 * flash;
      const textAlpha = 0.35 + 0.65 * flash;

      ctx.save();
      ctx.fillStyle = `rgba(0,0,0,${alpha})`;
      ctx.fillRect(0, 0, world.w, world.h);

      ctx.globalAlpha = textAlpha;
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "26px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Welcome Medical student to our busy hospital", world.w/2, world.h/2);
      ctx.restore();
    }

    // Level-up banner
    if (levelBanner.active) {
      const p = levelBanner.t / levelBanner.dur;
      const flash = Math.max(0, 1 - p);
      const alpha = 0.15 + 0.75 * flash;
      const textAlpha = 0.35 + 0.65 * flash;

      ctx.save();
      ctx.fillStyle = `rgba(0,0,0,${alpha})`;
      ctx.fillRect(0, 0, world.w, world.h);

      ctx.globalAlpha = textAlpha;
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "24px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Congratulations your contract has been renewed for another year", world.w/2, world.h/2 - 18);

      const title = levelBanner.title ? ` — ${levelBanner.title}` : "";
      ctx.font = "20px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.fillStyle = "rgba(122,162,255,.95)";
      ctx.fillText(`Level ${levelBanner.level}${title}`, world.w/2, world.h/2 + 20);
      ctx.restore();
    }

    // paused overlay
    if (paused) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0, 0, world.w, world.h);
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "28px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Paused", world.w/2 - 44, world.h/2);
      ctx.restore();
    }

    // start overlay when not running
    if (!running) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(0, 0, world.w, world.h);
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "28px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.fillText("Press Start", world.w/2 - 72, world.h/2);
      ctx.restore();
    }
  }

  function loop(ts){
    if (!running) return;
    const dt = Math.min(0.033, (ts - lastTs) / 1000);
    lastTs = ts;
    if (!paused) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  statusPill.innerHTML = "Press <b>Start</b>";
})();
</script>
</body>
</html>